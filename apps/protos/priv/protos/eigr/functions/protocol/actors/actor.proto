syntax = "proto3";

package eigr.functions.protocol.actors;

import "google/protobuf/any.proto";

option java_package = "io.eigr.functions.protocol.actors";
option go_package = "github.com/eigr/go-support/eigr/actors;actors";

message Registry {
    map<string, Actor> actors = 1;
}

message ActorSystem {
    string name = 1;
    Registry registry = 2;
}

// A strategy based on a timeout. 
message TimeoutStrategy {
    // The timeout in millis
    int64 timeout = 1;
}

// A strategy based on Functions calls.
// Persistent storage will be called after the invocation has been processed
message AfterCallCommandStrategy {}

// A strategy based on Functions calls.
// Persistent storage will be called before the invocation has been processed
message BeforeCallCommandStrategy {}

// A strategy under user control
message UserDefinedStrategy {}

// A strategy for save state.
message ActorSnapshotStrategy {
    oneof strategy {
        // Timeout strategy.
        // Call the statestore when the timeout is triggered. This is default strategy.
        TimeoutStrategy timeout = 1;

        // Command strategy
        // Call the statestore after the actor function has been invoked.
        AfterCallCommandStrategy after_command = 2;

        // Command strategy
        // Call the statestore before the actor function has been invoked.
        BeforeCallCommandStrategy before_command = 3;

        // User strategy
        // No persistence will be performed until the user explicitly requests this to occur. 
        // The user can do this by sending an ActionResponse with the "persist" attribute set to true.
        UserDefinedStrategy user_defined = 4;
    }
}

// A strategy which a user function's entity is passivated.
message ActorDeactivateStrategy {
    oneof strategy {
        // Timeout strategy.
        TimeoutStrategy timeout = 2;
    }
}

// Represents the state of Actor
message ActorState {
    map<string, string> tags = 1;
    google.protobuf.Any state = 2;
}

// A command represents an action that the user can perform on an Actor. 
// Commands in supporting languages are represented by functions or methods.
// An Actor command has nothing to do with the semantics of Commands in a CQRS/EventSourced system. 
// It just represents an action that supporting languages can invoke.
message Command {

    // The name of the function or method in the supporting language that has been registered in Ator.
    string name = 1;

    // Number of function or method arguments in the supporting language. 
    // The maximum number of arguments for a command is two arguments, 
    // one being for sending the payload to the function and the other 
    // being commonly used for sending the current state of the actor.
    int32 arity = 2;
}

// A TimerCommand is similar to a regular Command, its main differences are that it is scheduled to run at regular intervals 
// and only takes the actor's state as an argument.
// Timer Commands are good for executing loops that manipulate the actor's own state. 
// In Elixir or other languages in BEAM it would be similar to invoking Process.send_after(self(), atom, msg, timeout)
message TimerCommand {

    // The time to wait until the command is triggered
    int32 seconds = 1;

    // See Command description Above
    Command command = 2;
}

// A Actor instance identification
message ActorId {
    // The name of a Actor Entity.
    string name = 1;
    
    // A user function defines an actor that has a ´name´ as part of its unique key in persistent storage, 
    // this identification mechanism is sometimes not sufficient to identify an actor 
    // when the invocation mechanism requires that multiple instances of an actor can be created. 
    // An entity id is used to compose the uri that identifies the Actor in persistent storage.
    // Default is ´"actor://system/:system_name/actors/:name/parent´
    string resource = 2;

    // Name of a ActorSystem
    string actor_system = 3;
}

// Actor abstraction.
message Actor {
    // The id of Actor.
    ActorId actor_id = 1;

    // Indicates whether an actor's state should be persisted in a definitive store.
    bool persistent = 2;
    
    // A Actor state.
    ActorState state = 3;

    // The commands registered for an actor
    repeated Command commands = 4;

    // The registered timers for an actor.
    repeated TimerCommand timers = 5;

    // Snapshot strategy
    ActorSnapshotStrategy snapshot_strategy = 6;

    // Deactivate strategy
    ActorDeactivateStrategy deactivate_strategy = 7;
}